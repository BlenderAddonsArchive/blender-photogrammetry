import os
import re
import subprocess
import shutil
import platform

import bpy
from math import pi
from mathutils import Matrix, Vector, Euler

#from ..pmvs.load import prepare_workspace
from ..utils import set_active_collection, get_binpath_for_module, get_binary_path, get_image_size
from .read_model import Camera, Image, Point3D
from .write_model import write_model

"""
COLMAP workspace:

/
    dense/ (generated by image_undistorter command)
        images/
            [undistorted images...]
        sparse/ (undistorted parameters)
            cameras.txt
            images.txt
            points3D.txt
        stereo/
            consistency_graphs/
            depth_maps/
            normal_maps/
            fusion.cfg
            patch_match.cfg
        fused.ply <-- created after stereo_fusion, must be called this for delaunay_mesher
    images/
        [distorted images...]
    sparse/ (distorted parameters)
        cameras.txt
        images.txt
        points3D.txt

Also a note for the automatic reconstruction:
https://github.com/colmap/colmap/issues/557#issuecomment-458117528
dense/images are undistorted, dense/sparse is the undistorted sparse reconstruction with undistorted image observations and cameras.

# https://colmap.github.io/cli.html#cli
COLMAP.bat image_undistorter --image_path C:\...\workspace\images --input_path C:\...\workspace\sparse --output_path C:\...\workspace\dense --output_type COLMAP
COLMAP.bat patch_match_stereo --workspace_path C:\...\workspace
COLMAP.bat stereo_fusion --workspace_path C:\...\workspace --output_path C:\...\workspace\fused.ply
COLMAP.bat poisson_mesher --input_path C:\...\workspace\meshed.ply --output_path C:\..\workspace\reconstruction-colmap-poisson.ply

To run openMVS InterfaceCOLMAP we need TXT version of dense workspace, run this:
COLMAP.bat model_converter --input_path C:\...\workspace\dense\sparse --output_path C:\...\workspace\dense\sparse --output_type TXT

# openMVS meshing:
InterfaceCOLMAP.exe -i C:\..\workspace\dense -o C:\..\workspace\mvs\colmap.mvs
ReconstructMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap.mvs
RefineMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap_mesh.mvs
TextureMesh.exe --working-folder C:\..\workspace\mvs\ colmap_mesh.mvs --export-type obj
"""

def load(properties, data, *args, **kwargs):
    dirpath = bpy.path.abspath(properties.dirpath)
    binpath = get_binpath_for_module(os.path.realpath(__file__))
    env = os.environ.copy()
    if platform.system().lower() == 'windows':
        env.update({
            'PATH': f"{binpath}\lib;{env.get('PATH', '')}",
            'QT_PLUGIN_PATH': f"{binpath}\lib;{env.get('QT_PLUGIN_PATH', '')}",
            'DATASET_PATH': dirpath
        })

    # convert our representation to the COLMAP model format
    for path in ['images', 'sparse', 'dense']:
        path = os.path.join(dirpath, path)
        if not os.path.exists(path):
            os.makedirs(path)

    cameras = []
    images = []
    points3D = []
    for cid, camera in data['cameras'].items():
        if not cameras:
            resolution = data.get('resolution', None)
            if not resolution:
                resolution = get_image_size(camera['filename'])
            # PINHOLE params: [fx, fy, cx, cy]
            params = [camera['f'], camera['f']] + list(camera.get('principal', map(lambda a: a / 2.0, resolution)))
            cameras.append(Camera(1, 'PINHOLE', resolution[0], resolution[1], params))

        R = Matrix(camera['R'])
        t = Vector(camera['t'])
        R.transpose()
        c = -1 * R @ t
        R.transpose()
        R.rotate(Euler((pi, 0, 0)))
        T = -1 * R @ c
        qvec = tuple(R.to_quaternion())
        tvec = tuple(T)

        xys = []
        point3D_ids = []
        for tid, tracker in camera['trackers'].items():
            co = list(tracker)
            co[0] = co[0] + resolution[0] / 2.0 - 0.5
            co[1] = co[1] + resolution[1] / 2.0 - 0.5
            xys.append(co)
            point3D_ids.append(tid)
        filename = os.path.basename(camera['filename'])
        shutil.copy(camera['filename'], os.path.join(dirpath, 'images', filename))
        images.append(Image(cid, qvec, tvec, 1, filename, xys, point3D_ids))

    for tid, tracker in data['trackers'].items():
        image_ids = []
        point2D_idxs = []
        # find all the cameras that reference this 3D point
        for cid, camera in data['cameras'].items():
            if tid in camera['trackers']:
                image_ids.append(cid)
                point2D_idxs.append(list(camera['trackers'].keys()).index(tid))
        points3D.append(Point3D(tid, tracker['co'], tracker['rgb'], tracker.get('error', 0.0), image_ids, point2D_idxs))

    write_model(os.path.join(dirpath, 'sparse'), '.txt', cameras, images, points3D)

    # calculate all the paths used through COLMAP processing
    colmap_path = get_binary_path(binpath, 'colmap')
    sparse_path = os.path.join(dirpath, 'sparse')
    dense_path = os.path.join(dirpath, 'dense')
    point_cloud_path = os.path.join(dense_path, 'fused.ply')
    poisson_mesh_path = os.path.join(dense_path, 'meshed-poisson.ply')
    delaunay_mesh_path = os.path.join(dense_path, 'meshed-delaunay.ply')

    args = [
        colmap_path,
        'image_undistorter',
        '--image_path', os.path.join(dirpath, 'images'),
        '--input_path', sparse_path,
        '--output_path', dense_path,
        '--output_type', 'COLMAP',
    ] + (['--max_image_size', str(properties.max_image_size)] if properties.max_image_size > 0 else [])
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP image_undistorter failed, see system console for details')

    args = [
        colmap_path,
        'patch_match_stereo',
        '--workspace_path', dense_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP patch_match_stereo failed, see system console for details')

    args = [
        colmap_path,
        'stereo_fusion',
        '--workspace_path', dense_path,
        '--output_path', point_cloud_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP stereo_fusion failed, see system console for details')
        
    args = [
        colmap_path,
        'poisson_mesher',
        '--input_path', point_cloud_path,
        '--output_path', poisson_mesh_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP poisson_mesher failed, see system console for details')
        
    args = [
        colmap_path,
        'delaunay_mesher',
        '--input_path', dense_path,
        '--output_path', delaunay_mesh_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP delaunay_mesher failed, see system console for details')

    if properties.import_points:
        set_active_collection(**kwargs)
        if os.path.exists(point_cloud_path): bpy.ops.import_mesh.ply(filepath=point_cloud_path)
        if os.path.exists(poisson_mesh_path): bpy.ops.import_mesh.ply(filepath=poisson_mesh_path)
        if os.path.exists(delaunay_mesh_path): bpy.ops.import_mesh.ply(filepath=delaunay_mesh_path)
