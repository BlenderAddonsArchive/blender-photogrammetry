import os
import re
import subprocess
import shutil
import platform

import bpy
from mathutils import Matrix, Vector, Euler

#from ..pmvs.load import prepare_workspace
from ..utils import set_active_collection, get_binpath_for_module, get_binary_path, get_image_size
from .read_model import Camera, Image, Point3D
from .write_model import write_model

"""
COLMAP workspace:

/
    dense/ (generated by image_undistorter command)
        images/
            [undistorted images...]
        sparse/ (undistorted parameters)
            cameras.txt
            images.txt
            points3D.txt
        stereo/
            consistency_graphs/
            depth_maps/
            normal_maps/
            fusion.cfg
            patch_match.cfg
        fused.ply <-- created after stereo_fusion, must be called this for delaunay_mesher
    images/
        [distorted images...]
    sparse/ (distorted parameters)
        cameras.txt
        images.txt
        points3D.txt

Also a note for the automatic reconstruction:
https://github.com/colmap/colmap/issues/557#issuecomment-458117528
dense/images are undistorted, dense/sparse is the undistorted sparse reconstruction with undistorted image observations and cameras.

# https://colmap.github.io/cli.html#cli
COLMAP.bat image_undistorter --image_path C:\...\workspace\images --input_path C:\...\workspace\sparse --output_path C:\...\workspace\dense --output_type COLMAP
COLMAP.bat patch_match_stereo --workspace_path C:\...\workspace
COLMAP.bat stereo_fusion --workspace_path C:\...\workspace --output_path C:\...\workspace\fused.ply
COLMAP.bat poisson_mesher --input_path C:\...\workspace\meshed.ply --output_path C:\..\workspace\reconstruction-colmap-poisson.ply

To run openMVS InterfaceCOLMAP we need TXT version of dense workspace, run this:
COLMAP.bat model_converter --input_path C:\...\workspace\dense\sparse --output_path C:\...\workspace\dense\sparse --output_type TXT

# openMVS meshing:
InterfaceCOLMAP.exe -i C:\..\workspace\dense -o C:\..\workspace\mvs\colmap.mvs
ReconstructMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap.mvs
RefineMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap_mesh.mvs
TextureMesh.exe --working-folder C:\..\workspace\mvs\ colmap_mesh.mvs --export-type obj
"""

def load(properties, data, *args, **kwargs):
    dirpath = bpy.path.abspath(properties.dirpath)
    binpath = get_binpath_for_module(os.path.realpath(__file__))
    env = os.environ.copy()
    if platform.system().lower() == 'windows':
        env.update({
            'PATH': f"{binpath}\lib;{env.get('PATH', '')}",
            'QT_PLUGIN_PATH': f"{binpath}\lib;{env.get('QT_PLUGIN_PATH', '')}",
            'DATASET_PATH': dirpath
        })

    # convert our representation to the COLMAP model format
    for path in ['images', 'sparse', 'dense']:
        path = os.path.join(dirpath, path)
        if not os.path.exists(path):
            os.makedirs(path)

    cameras = []
    images = []
    points3D = []
    for cid, camera in data['cameras'].items():
        if not cameras:
            resolution = data.get('resolution', None)
            if not resolution:
                resolution = get_image_size(camera['filename'])
            # PINHOLE params: [fx, fy, cx, cy]
            params = [camera['f'], camera['f']] + list(camera.get('principal', map(lambda a: a / 2.0, resolution)))
            cameras.append(Camera(1, 'PINHOLE', resolution[0], resolution[1], params))

        qvec = tuple(Matrix(camera['R']).to_quaternion())
        tvec = tuple(Vector(camera['t']))
        xys = []
        point3D_ids = []
        shutil.copy(camera['filename'], os.path.join(dirpath, 'images', os.path.basename(camera['filename'])))
        images.append(Image(cid, qvec, tvec, 1, camera['filename'], xys, point3D_ids))

    for tid, tracker in data['trackers'].items():
        image_ids = []
        point2D_idxs = []
        points3D.append(Point3D(tid, tracker['co'], tracker['rgb'], 0.0, image_ids, point2D_idxs))

    write_model(os.path.join(dirpath, 'sparse'), '.txt', cameras, images, points3D)
    raise NotImplementedError('Wrote COLMAP model. Calling COLMAP binaries on hold.')

    colmap_path = get_binary_path(binpath, 'colmap')
    point_cloud_path = os.path.join(dirpath, 'dense', 'fused.ply')
    poisson_path = os.path.join(dirpath, 'dense', 'meshed-poisson.ply')
    delaunay_path = os.path.join(dirpath, 'dense', 'meshed-delaunay.ply')

    args = [
        colmap_path,
        'image_undistorter',
        '--image_path', os.path.join(dirpath, 'images'),
        '--input_path', os.path.join(dirpath, 'sparse'),
        '--output_path', os.path.join(dirpath, 'dense'),
        '--output_format', 'COLMAP',
    ] + (['--max_image_size', str(properties.max_image_size)] if properties.max_image_size > 0 else [])
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP image_undistorter failed, see system console for details')

    args = [
        colmap_path,
        'patch_match_stereo',
        '--workspace_path', os.path.join(dirpath, 'dense'),
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP patch_match_stereo failed, see system console for details')

    args = [
        colmap_path,
        'stereo_fusion',
        '--workspace_path', os.path.join(dirpath, 'dense'),
        '--output_path', point_cloud_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP stereo_fusion failed, see system console for details')
        
    args = [
        colmap_path,
        'poisson_mesher',
        '--input_path', os.path.join(dirpath, 'dense', 'fused.ply'),
        '--output_path', poisson_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP poisson_mesher failed, see system console for details')
        
    args = [
        colmap_path,
        'delaunay_mesher',
        '--input_path', os.path.join(dirpath, 'dense'),
        '--output_path', delaunay_path,
    ]
    print(' '.join(args))
    retcode = subprocess.call(args, env=env)
    if retcode != 0:
        raise Exception('COLMAP delaunay_mesher failed, see system console for details')

    if properties.import_points:
        set_active_collection(**kwargs)
        if os.path.exists(point_cloud_path): bpy.ops.import_mesh.ply(filepath=point_cloud_path)
        if os.path.exists(poisson_path): bpy.ops.import_mesh.ply(filepath=poisson_path)
        if os.path.exists(delaunay_path): bpy.ops.import_mesh.ply(filepath=delaunay_path)
