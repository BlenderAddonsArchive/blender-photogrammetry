import os
import re
import subprocess
import shutil
import platform

import bpy
from math import pi
from mathutils import Matrix, Vector, Euler

from ..openmvs.utils import interface_colmap, reconstruct_mesh, texture_mesh
from ..utils import set_active_collection, get_binpath_for_module, get_binary_path, get_image_size
from .read_model import Camera, Image, Point3D
from .write_model import write_model

"""
COLMAP workspace:

/
    dense/ (generated by image_undistorter command)
        images/
            [undistorted images...]
        sparse/ (undistorted parameters)
            cameras.txt
            images.txt
            points3D.txt
        stereo/
            consistency_graphs/
            depth_maps/
            normal_maps/
            fusion.cfg
            patch_match.cfg
        fused.ply <-- created after stereo_fusion, must be called this for delaunay_mesher
    images/
        [distorted images...]
    sparse/ (distorted parameters)
        cameras.txt
        images.txt
        points3D.txt

Also a note for the automatic reconstruction:
https://github.com/colmap/colmap/issues/557#issuecomment-458117528
dense/images are undistorted, dense/sparse is the undistorted sparse reconstruction with undistorted image observations and cameras.

# https://colmap.github.io/cli.html#cli
COLMAP.bat image_undistorter --image_path C:\...\workspace\images --input_path C:\...\workspace\sparse --output_path C:\...\workspace\dense --output_type COLMAP
COLMAP.bat patch_match_stereo --workspace_path C:\...\workspace
COLMAP.bat stereo_fusion --workspace_path C:\...\workspace --output_path C:\...\workspace\fused.ply
COLMAP.bat poisson_mesher --input_path C:\...\workspace\meshed.ply --output_path C:\..\workspace\reconstruction-colmap-poisson.ply

To run openMVS InterfaceCOLMAP we need TXT version of dense workspace, run this:
COLMAP.bat model_converter --input_path C:\...\workspace\dense\sparse --output_path C:\...\workspace\dense\sparse --output_type TXT

# openMVS meshing:
InterfaceCOLMAP.exe -i C:\..\workspace\dense -o C:\..\workspace\mvs\colmap.mvs
ReconstructMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap.mvs
RefineMesh.exe --working-folder C:\..\workspace\mvs\ --input-file colmap_mesh.mvs --max-face-area 16
TextureMesh.exe --working-folder C:\..\workspace\mvs\ colmap_mesh.mvs --export-type obj
"""

def load(properties, data, *args, **kwargs):
    dirpath = bpy.path.abspath(properties.dirpath)
    overwrite = properties.overwrite
    binpath = get_binpath_for_module(os.path.realpath(__file__))
    env = os.environ.copy()
    if platform.system().lower() == 'windows':
        env.update({
            'PATH': f"{binpath}\lib;{env.get('PATH', '')}",
            'QT_PLUGIN_PATH': f"{binpath}\lib;{env.get('QT_PLUGIN_PATH', '')}",
            'DATASET_PATH': dirpath
        })

    # convert our representation to the COLMAP model format
    for path in ['images', 'sparse', 'dense']:
        path = os.path.join(dirpath, path)
        if overwrite and os.path.exists(path):
            shutil.rmtree(path)
            while os.path.exists(path):
                pass
        if not os.path.exists(path):
            os.makedirs(path)

    txt_model_files = set(['cameras.txt', 'images.txt', 'points3D.txt'])
    bin_model_files = set(['cameras.bin', 'images.bin', 'points3D.bin'])
    if txt_model_files != set(os.listdir(os.path.join(dirpath, 'sparse'))).intersection(txt_model_files):
        cameras = []
        images = []
        points3D = []
        for cid, camera in data['cameras'].items():
            if not cameras:
                resolution = data.get('resolution', None)
                if not resolution:
                    resolution = get_image_size(camera['filename'])
                # PINHOLE params: [fx, fy, cx, cy]
                params = [camera['f'], camera['f']] + list(camera.get('principal', map(lambda a: a / 2.0, resolution)))
                cameras.append(Camera(1, 'PINHOLE', resolution[0], resolution[1], params))

            R = Matrix(camera['R'])
            t = Vector(camera['t'])
            R.transpose()
            c = -1 * R @ t
            R.transpose()
            R.rotate(Euler((pi, 0, 0)))
            T = -1 * R @ c
            qvec = tuple(R.to_quaternion())
            tvec = tuple(T)

            xys = []
            point3D_ids = []
            for tid, tracker in camera['trackers'].items():
                co = list(tracker)
                co[0] = co[0] + resolution[0] / 2.0 - 0.5
                co[1] = co[1] + resolution[1] / 2.0 - 0.5
                xys.append(co)
                point3D_ids.append(tid)
            filename = os.path.basename(camera['filename'])
            shutil.copy(camera['filename'], os.path.join(dirpath, 'images', filename))
            images.append(Image(cid, qvec, tvec, 1, filename, xys, point3D_ids))

        for tid, tracker in data['trackers'].items():
            image_ids = []
            point2D_idxs = []
            # find all the cameras that reference this 3D point
            for cid, camera in data['cameras'].items():
                if tid in camera['trackers']:
                    image_ids.append(cid)
                    point2D_idxs.append(list(camera['trackers'].keys()).index(tid))
            points3D.append(Point3D(tid, tracker['co'], tracker['rgb'], tracker.get('error', 0.0), image_ids, point2D_idxs))

        write_model(os.path.join(dirpath, 'sparse'), '.txt', cameras, images, points3D)

    # exit if we're not asked to perform dense reconstruction
    if not (properties.import_points or properties.import_poisson or properties.import_delaunay or properties.import_openmvs):
        return

    # calculate all the paths used through COLMAP processing
    colmap_path = get_binary_path(binpath, 'colmap')
    sparse_path = os.path.join(dirpath, 'sparse')
    dense_path = os.path.join(dirpath, 'dense')
    point_cloud_path = os.path.join(dense_path, 'fused.ply')
    poisson_mesh_path = os.path.join(dense_path, 'meshed-poisson.ply')
    delaunay_mesh_path = os.path.join(dense_path, 'meshed-delaunay.ply')
    openmvs_workspace = os.path.join(dirpath, 'openmvs')
    openmvs_mesh_path = os.path.join(openmvs_workspace, 'scene_mesh_texture.obj')

    # image_undistorter, patch_match_stereo and stereo_fusion required for dense reconstruction
    try:
        reconstruct = set(os.listdir(os.path.join(dirpath, 'images'))) != set(os.listdir(os.path.join(dense_path, 'images'))) or bin_model_files != set(os.listdir(os.path.join(dense_path, 'sparse'))).intersection(bin_model_files)
    except FileNotFoundError:
        reconstruct = True
    
    if reconstruct:
        args = [
            colmap_path,
            'image_undistorter',
            '--image_path', os.path.join(dirpath, 'images'),
            '--input_path', sparse_path,
            '--output_path', dense_path,
            '--output_type', 'COLMAP',
        ] + (['--max_image_size', str(properties.max_image_size)] if properties.max_image_size > 0 else [])
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP image_undistorter failed, see system console for details')

        args = [
            colmap_path,
            'patch_match_stereo',
            '--workspace_path', dense_path,
        ]
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP patch_match_stereo failed, see system console for details')

        args = [
            colmap_path,
            'stereo_fusion',
            '--workspace_path', dense_path,
            '--output_path', point_cloud_path,
        ]
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP stereo_fusion failed, see system console for details')
    
    if properties.import_poisson and (overwrite or not os.path.exists(poisson_mesh_path)):
        args = [
            colmap_path,
            'poisson_mesher',
            '--input_path', point_cloud_path,
            '--output_path', poisson_mesh_path,
        ]
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP poisson_mesher failed, see system console for details')
    
    if properties.import_delaunay and (overwrite or not os.path.exists(delaunay_mesh_path)):
        args = [
            colmap_path,
            'delaunay_mesher',
            '--input_path', dense_path,
            '--output_path', delaunay_mesh_path,
        ]
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP delaunay_mesher failed, see system console for details')

    if properties.import_openmvs and (overwrite or not os.path.exists(openmvs_mesh_path)):
        # convert the dense model into TXT format as openMVS only supports TXT
        # --input_path C:\...\workspace\dense\sparse --output_path C:\...\workspace\dense\sparse --output_type TXT
        args = [
            colmap_path,
            'model_converter',
            '--input_path', os.path.join(dense_path, 'sparse'),
            '--output_path', os.path.join(dense_path, 'sparse'),
            '--output_type', 'TXT'
        ]
        print(' '.join(args))
        retcode = subprocess.call(args, env=env)
        if retcode != 0:
            raise Exception('COLMAP model_converter failed, see system console for details')
        
        # now that the model has been converted, run openMVS stages
        interface_colmap(openmvs_workspace, dense_path, os.path.join(openmvs_workspace, 'scene.mvs'))
        reconstruct_mesh(openmvs_workspace)
        texture_mesh(openmvs_workspace)

    set_active_collection(**kwargs)
    if properties.import_points and os.path.exists(point_cloud_path):
        bpy.ops.import_mesh.ply(filepath=point_cloud_path)

    if properties.import_poisson and os.path.exists(poisson_mesh_path):
        bpy.ops.import_mesh.ply(filepath=poisson_mesh_path)

    if properties.import_delaunay and os.path.exists(delaunay_mesh_path):
        bpy.ops.import_mesh.ply(filepath=delaunay_mesh_path)

    if properties.import_openmvs and os.path.exists(openmvs_mesh_path):
        bpy.ops.import_scene.obj(filepath=openmvs_mesh_path, axis_forward='Y', axis_up='Z')
